# Algorithms - Notes of everything on this course
## è¿›åº¦
### è¿›åº¦.todo
- week2
	- stacks @done(2017-12-10)
	- resizing arrays @done(2017-12-10)
	- queues @done(2017-12-10)
	- generics @done(2017-12-10)
	- iteration @done(2017-12-10)
	- Bag @done(2017-12-10)
	- stack and queue applications @done(2017-12-11)
	- programming assignment @done(2017-12-14)
		- dequeue @done(2017-12-12)
		- randomizedQueue @done(2017-12-13)
		- client @done(2017-12-14)
- week3
	- sorting Introduction @done(2017-12-15)
	- selection sort @done(2017-12-15)
	- insertion sort
	- shellsort
	- shuffling
	- convex hull

### week2
#### stacks
é¡ºåºï¼šå®šä¹‰APIï¼Œå†™client(å¯¹APIçš„æµ‹è¯•å‡½æ•°)ï¼Œæœ€åimplement
##### API.todo
- StackOfString() @done(2017-12-10)
- void push(String item) @done(2017-12-10)
- String pop() @done(2017-12-10)
- boolean isEmpty() @done(2017-12-10)
- int size() @done(2017-12-10)
##### client
```java
// è¯»å–ä¸€è¡Œnä¸ªå­—ç¬¦ä¸²ï¼Œé‡-popï¼Œå¦åˆ™pushï¼Œæœ€åæ‰“å°size
public static void main(String[] args) {
	String s;
	StackOfString stack = new StackOfString();
	while (!StdIn.isEmpty()) {
		s = StdIn.readString();
		if (s.equals("-")) stack.pop(); // string.equals(string2);
		stack.push(s);
	}
	StdOut.println(stack.size());
}

```
2.1 input:
to be - or not - - to be 
output:
3 
æ­¤æ—¶stackå†…æ˜¯be to to
##### implement(use linked-list)
é”™è¯¯ï¼š
1. æ‰€æœ‰å‡½æ•°(åŒ…æ‹¬æ„é€ å‡½æ•°)éƒ½éœ€è¦æœ‰() {}ï¼Œç‰¹åˆ«æ˜¯æ„é€ å‡½æ•°ï¼Œè€å¿˜è®°å†™ã€‚
2. false å†™é”™äº†ï¼Œä¸æ˜¯fasle
3. isEmpty å†™é”™äº†
4. å‘½ä»¤è¡Œé‡Œè¾“å…¥æ–‡ä»¶ç»“æŸç¬¦æ˜¯ï¼šctrl-d (å¯èƒ½ä¼šå’Œå…¶ä»–è½¯ä»¶çš„å¿«æ·é”®å†²çª)

```java
public class StackOfString {

	public class Node {
		String item;
		Node next;
	}

	private int count;
	private Node first;
	public StackOfString() {  // 1 â€”â€”> public StackOfString() {}
		count = 0;
		first = new Node();
	}
	public void push(String item) {
		Node p = new Node();
		p.item = item;
		p.next = first;
		first = p;
		count ++;
	}
	public String pop() {
		if (isEmpty()) return ""; // 2 â€”â€”> false å†™é”™äº†
		p = first;
		first = first.next; // 5 â€”â€”> frist.next = first.next å†™é”™äº†ã€‚
		p.next = null;
		count--;
		return p.item;
	}
	public boolean isEmpty() {  // 3 â€”â€”> isEmpty å†™é”™äº†
		return count == 0;
	}
	public int size() {
		return count;
	}
	// è¯»å–ä¸€è¡Œnä¸ªå­—ç¬¦ä¸²ï¼Œé‡-popï¼Œå¦åˆ™pushï¼Œæœ€åæ‰“å°size
	public static void main(String[] args) {
		String s;
		StackOfString stack = new StackOfString();
		while (!StdIn.isEmpty()) {
			s = StdIn.readString();
			if (s.equals("-")) stack.pop(); // string.equals(string2);
			else stack.push(s);
		}
		StdOut.println(stack.size());
	}	
}

```
##### timing and memory(use linked-list)
1. timingæ€ä¹ˆåˆ†æï¼Ÿ
ä¸»è¦çœ‹æ¯ä¸ªmethodåšçš„æ“ä½œå’Œn(æ•°æ®è§„æ¨¡)æœ‰æ²¡æœ‰å…³ç³»ï¼›
åœ¨StackOfStringé‡Œé¢ï¼Œå¾ˆæ˜æ˜¾ï¼Œä¸ç®¡åŠ å…¥å¤šå°‘ä¸ªnodeï¼Œpopå’Œpushçš„æ“ä½œå°±æ˜¯é‚£ä¹ˆå‡ ä¸ªï¼Œæ²¡æœ‰nï¼Œæ‰€ä»¥æ˜¯constantã€‚
2. memoryæ€ä¹ˆåˆ†æï¼Ÿ
çœ‹ä¸»è¦çš„æ•°æ®å­˜å‚¨ç»“æ„å’Œnä¹‹é—´çš„å…³ç³»ï¼›
åœ¨StackOfStringé‡Œé¢ï¼Œå¾ˆæ˜æ˜¾ï¼Œä¸»è¦çš„æ•°æ®ç»“æ„å°±æ˜¯nä¸ªnodeï¼Œæ²¡æœ‰å…¶ä»–çš„äº†ã€‚é‚£ä¹ˆ`memory = size(Node)*N`.
##### implement(use array)
é”™è¯¯ï¼š1. å¿˜äº†æ•°ç»„æ˜¯ä»0å¼€å§‹è®¡æ•°çš„ã€‚countæ˜¯è®¡æ•°ï¼Œcapacityä¹Ÿæ˜¯è®¡æ•°ï¼Œä½†æ•°ç»„ä¸‹æ ‡éœ€è¦å‡ä¸€ã€‚å¦‚æœè¦æŠŠcountåˆåšè®¡æ•°åˆåšä¸‹æ ‡å–æ•°ï¼Œé‚£ä¹ˆæ‰€æœ‰ä¸‹æ ‡å–æ•°çš„åœ°æ–¹éƒ½è¦-1ï¼›
```java 
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class StackOfStringArray {
	private String[] stack;
	private int capacity;
	private int count;
	public StackOfString(int n) {
		capacity = n;
		count = 0;
		stack = new String[n];
	}
	public void push(String s) {
		// 1â€”â€”â€”â€”>
		// if (count == capacity) throw new java.lang.IllegalArgumentException("stack is full"); 
		// else {
		//	stack[count+1] = s;
		//	count ++; 
		
		if (count >= capacity) throw new java.lang.IllegalArgumentException("stack is full"); 
		else {
			stack[count] = s;
			count ++;
		}
	}
	public String pop() {
		String s = stack[count-1];
		stack[count-1] = null;
		count --;
		return s;
	}
	public boolean isEmpty() {
		return count == 0;
	}
	public int size() {
		return count;
	}
}
```
##### timing and memory(using array)
1. timing
æ„å»ºå‡½æ•°æ˜¯1ï¼Œå…¶ä»–å‡½æ•°ä¹ŸåŸºæœ¬éƒ½æ˜¯1ï¼Œå’Œnæ— å…³ã€‚
2. memory
ä¸»è¦æ•°æ®ç»“æ„æ˜¯nçš„arrayã€‚
##### æ€»ç»“()
é“¾è¡¨çš„å®ç°å…³é”®è¦æƒ³æ¸…æ¥šåœ¨äºnodeçš„æŒ‡å‘æ–¹å‘ã€‚ä½ è¦æƒ³åˆ°ï¼Œå¦‚æœæŒ‡å‘æ–¹å‘ä¹Ÿæ˜¯stackçš„é¡¶ç«¯çš„è¯ï¼Œé‚£æˆ‘ä»¬å°±æ²¡åŠæ³•çŸ¥é“firstä¸‹é¢ç¬¬äºŒä¸ªæ˜¯ä»€ä¹ˆï¼Œå°±æ²¡åŠæ³•æ‰§è¡Œåˆ é™¤çš„æ“ä½œï¼›æ‰€ä»¥æŒ‡å‘æ–¹å‘å¿…é¡»æ˜¯stacké¡¶ç«¯ç›¸åï¼Œé¡¶ç«¯ç¬¬ä¸€ä¸ªnodeæŒ‡å‘çš„æ˜¯å®ƒä¸‹é¢çš„nodeï¼Œæˆ‘ä»¬å°±èƒ½çŸ¥é“è¿™ä¸ªnodeä¹‹å‰çš„ä¸€ä¸ªnodeæ˜¯ä»€ä¹ˆï¼Œå°±èƒ½æ‰§è¡Œåˆ é™¤æ“ä½œã€‚
#### resizing arrays
æ€è·¯ï¼špushçš„æ—¶å€™ï¼Œæ£€æŸ¥count æ˜¯å¦åˆ°äº† capacity, æ˜¯çš„è¯å°±æŠŠcapacityåŠ å€ï¼›popçš„æ—¶å€™ï¼Œæ£€æŸ¥countæ˜¯å¦åˆ°äº†1/4capacityï¼Œæ˜¯çš„è¯å°±æŠŠcapacityæŠ˜åŠã€‚
é‡ç‚¹ï¼šresizeå‡½æ•°çš„å®ç°ï¼Œæœ€ç›´æ¥çš„æ–¹å¼å°±æ˜¯é‡æ–°åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œç„¶åæŠŠç°æœ‰æ•°ç»„ç»™å¤åˆ¶è¿‡å»ã€‚

##### implement
é”™è¯¯ï¼š1. å·²ç»æ˜¯instance varaibleçš„è¯ï¼Œmethodå¯ä»¥ä¸ç”¨ä¼ è¯¥æ•°æ®ç›´æ¥ä½¿ç”¨æˆ–ä¿®æ”¹ã€‚æ‰€ä»¥resize()ä¸éœ€è¦æŠŠstackä¼ å…¥è¿›å»ï¼Œç„¶åå†returnå‡ºæ¥ï¼Œç›´æ¥åœ¨å‡½æ•°é‡Œä¿®æ”¹å³å¯ã€‚
2. stack.length/2 éœ€è¦è€ƒè™‘ä¼šä¸ä¼šç­‰äº0ï¼ˆå› ä¸ºè¦ç”¨è¿™ä¸ªæ•°å»å¼€æ•°ç»„ï¼‰ï¼Œåªæœ‰stack.length=1çš„æ—¶å€™ï¼Œé‚£ä¹ˆcount=0çš„æ—¶å€™æ˜¯æ»¡è¶³count==1/4çš„ã€‚æ‰€ä»¥éœ€è¦æŠŠè¿™ä¸ªé™åˆ¶ä½ã€‚
```java
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class StackOfStringResizingArray {
	private String[] stack;
	private int count;
	public StackOfString() {
		count = 0;
		stack = new String[2];
	}
	private void resize(int n) {
		String[] after = new String[n];
		for (int i = 0; i < stack.length; i++) {
			after[i] = stack[i];
		}
		stack = after;
	}
	public void push(String s) {
		if (count == stack.length) stack = resize(2*stack.length);
		stack[count] = s;
		count ++;
	}
	public String pop() {
		String s = stack[count-1];
		stack[count-1] = null;
		count --;
		if (count == stack.length/4 && count > 0) stack = resize( stack.length/2);
		return s;
	}
	public boolean isEmpty() {
		return count == 0;
	}
	public int size() {
		return count;
	}
}
}
```
##### timing and memory(resizing array)
1. timing
å…¶ä»–æ“ä½œéƒ½æ˜¯1ï¼Œä½†éœ€è¦è€ƒè™‘çš„æ˜¯resizingè¿™ä¸ªå‡½æ•°çš„ç”¨æ—¶(å› ä¸ºæœ‰å¾ªç¯)ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œresizingè¿™ä¸ªå‡½æ•°ä¸ç®¡è¾“å…¥çš„næ˜¯å‡ ï¼Œéƒ½æ˜¯å¾ªç¯stack.lengthæ¬¡ã€‚æ‰€ä»¥ä¸€æ¬¡pop() å’Œpush()çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯Nã€‚
2. memory
ä¸»è¦æ•°æ®ç»“æ„å°±æ˜¯è¿™ä¸ªæ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„æœ€å¤§æ˜¯2*nã€‚
##### æ¯”è¾ƒresizing array å’Œ linked list
1. resizing array
 ä¼˜ç‚¹ï¼šå–ä»»æ„å…ƒç´ æ–¹ä¾¿ï¼Œpushå’Œpopæ–¹ä¾¿ï¼Œç©ºé—´åˆ©ç”¨å°‘
 ç¼ºç‚¹ï¼šåœ¨æŸäº›pushå’Œpopæ“ä½œéœ€è¦è°ƒæ•´æ•°ç»„
 é€‚ç”¨äºï¼šéœ€è¦å–æ•°çš„ï¼Œæˆ–è€…å¤§å‹stack
2. linked list
ä¼˜ç‚¹ï¼špushå’Œpopæ–¹ä¾¿
ç¼ºç‚¹ï¼šå–å…ƒç´ éº»çƒ¦ï¼Œéœ€è¦ç”¨é¢å¤–ç©ºé—´å‚¨å­˜nodeçš„æŒ‡å‘ã€‚
é€‚ç”¨äºï¼šä¸éœ€è¦å–å…ƒç´ ï¼Œå°å‹stackã€‚
#### queues
##### implement(queue using linked list)
é”™è¯¯ï¼š1. å½“queueä¸ºç©ºçš„æ—¶å€™ï¼Œå®šä¹‰äº†firstï¼Œä½†æ˜¯æ²¡æœ‰å®šä¹‰lastã€‚é‚£ä¹ˆå½“queueä¸ç©ºçš„æ—¶å€™ï¼Œæ­¤æ—¶è¦ç”¨lastï¼Œlastä»ä¸ºç©ºã€‚è¦åŠ ä¸Šlast = firstï¼›
2. ä»¥åä¸ºäº†é¿å…çŠ¯é”™ï¼Œifåè¿˜æ˜¯è¦åŠ elseçš„ã€‚if åªæœ‰åœ¨returnçš„æ—¶å€™æ‰ä¸ä¼šæ‰§è¡Œä¸‹é¢çš„è¯­å¥ï¼Œä½†è¿™æ ·è¯»ä»£ç çš„æ—¶å€™ä¹Ÿä¼šè´¹è§£ï¼Œä»ç„¶æ˜¯å¼Šå¤§äºåˆ©ã€‚
```java
public class QueueLinkedList{

	public class Node {
		String item;
		Node next;
	}

	private int count;
	private Node first, last;

	public QueueLinkedList() { 
		count = 0;
		first = new Node();
		last  = new Node();
	}
	public void enqueue(String item) {
		Node p = new Node();
		p.item = item;
		if (count == 0) {
			first = p;   // 1 â€”â€”
			last = first;
			p.next = null;
		}
		else {
			Node oldlast = last;
			last = p;
			oldlast.next = last;
		}
		count ++;
	}
	public String dequeue() {
		if (isEmpty()) return "";
		Node oldfirst = first;
		first = oldfirst.next;
		count--;
		return oldfirst.item;
	}
	public boolean isEmpty() { 
		return count == 0;
	}
	public int size() {
		return count;
	}
	// è¯»å–ä¸€è¡Œnä¸ªå­—ç¬¦ä¸²ï¼Œé‡- dequeueï¼Œå¦åˆ™enqueueï¼Œæœ€åæ‰“å°size
	public static void main(String[] args) {
		String s;
		QueueLinkedList queue = new QueueLinkedList();
		while (!StdIn.isEmpty()) {
			s = StdIn.readString();
			if (s.equals("-")) StdOut.println(queue.dequeue()); 
			else queue.enqueue(s);  // 2â€”â€”
		}
		StdOut.println(stack.size());
	}	
}
```
#### generics
é—®é¢˜ï¼šæ€æ ·è®¾è®¡èƒ½å¤Ÿæ¥å—å„ç§æ•°æ®ç±»å‹çš„æ•°æ®ç»“æ„ï¼Ÿ
è§£å†³æ–¹å¼ï¼šæ•°æ®ç»“æ„ç”¨genericså®ç°ï¼Œé‡Œé¢çš„æ•°æ®æŠ½è±¡æˆobject(item)ï¼Œclientåœ¨å£°æ˜è¿™ä¸ªæ•°æ®ç±»å‹çš„çš„æ—¶å€™å®šä¹‰è¿™æ¬¡çš„æ•°æ®ç±»å‹ã€‚
å®ç°ï¼šæ•°æ®ç»“æ„ä¸­æ‰€æœ‰æ•°æ®ç±»å‹éƒ½æ”¹æˆItemï¼Œç±»åæ—è¾¹åŠ <Item>. æ³¨æ„æ³›å‹çš„æ•°ç»„ï¼ša = (Item[]) new Object[n];(javaä¸å…è®¸ç›´æ¥å®šä¹‰æ³›å‹æ•°ç»„ï¼Œè¿™æ ·castingä¼šå¼•èµ·warning)
primitive type has a wrapper object typeï¼Œæ¯”å¦‚:
int -- Integer

```java
public class Stack<Item> {

	public class Node {
		Item item;
		Node next;
	}

	private int count;
	private Node first;
	public Stack() { 
		count = 0;
		first = new Node();
	}
	public void push(Item item) {
		Node p = new Node();
		p.item = item;
		p.next = first;
		first = p;
		count ++;
	}
	public Item pop() {
		if (isEmpty()) return ""; 
		p = first;
		first.next = first.next;
		p.next = null;
		count--;
		return p.item;
	}
	public boolean isEmpty() {  
		return count == 0;
	}
	public int size() {
		return count;
	}
	// è¯»å–ä¸€è¡Œnä¸ªå­—ç¬¦ä¸²ï¼Œé‡-popï¼Œå¦åˆ™pushï¼Œæœ€åæ‰“å°size
	public static void main(String[] args) {
		String s;
		Stack<String> stack = new Stack<String>();
		while (!StdIn.isEmpty()) {
			s = StdIn.readString();
			if (s.equals("-")) stack.pop(); // string.equals(string2);
			stack.push(s);
		}
		StdOut.println(stack.size());
	}	
}
```
#### iteration
ç›®çš„ï¼šTo iterate the item in that data structure
è§£å†³æ–¹å¼ï¼š
1. data structure çš„APIé‡Œå¢åŠ ä¸€ä¸ª`public Iterator<Item> iterator() { return new ListIterator(); }`
2. clientä¸­å°±å¯ä»¥ç›´æ¥ç”Ÿæˆä¸€ä¸ªiteratorï¼Œå®ƒæœ‰ä¸¤ä¸ªmethod `{ boolean hasNext(); Item next();}` ç›´æ¥ç”¨è¿™ä¸¤ä¸ªmethodè¿›è¡Œå¾ªç¯ï¼Œå¦‚ä¸‹:

```java
	Iterator<String> i = stack.iterator();
	while (i.hasNext()) {
		String s = i.next();
		StdOut.println(s);
	}
```

3. more elegant way (shorthand) : foreach
```java
for (String s : stack) 
	StdOut.println(s);
```

4. æˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯
	1. `import java.util.Iterator;`
	2. åœ¨classå£°æ˜çš„æ—¶å€™ä»`public class Stack<Item> {} ` æ”¹æˆ `public class Stack<Item> implements Iterable<Item> {}`
	3. å¢åŠ ä¸€ä¸ª`public Iterator<Item> iterator() { return new ListIterator(); }`
	4. å¢åŠ ä¸€ä¸ª`private class ListIterator implements Iterator<Item>{}`, å¹¶ä¸”åœ¨é‡Œé¢åˆ©ç”¨å®ç°`boolean hasNext()`å’Œ`Item next()`ä¸¤ä¸ªmethodã€‚
##### implement(using linked list)
é”™è¯¯ï¼š1. implements è€Œä¸æ˜¯implement
	2.ä¸æ˜¯`private class ListIterator implement Iterable<Item> {}` è€Œæ˜¯ `	private class ListIterator implement Iterator<Item> {}` æ³¨æ„Iteratorå’ŒIterableçš„åŒºåˆ«ã€‚
	 
```java
import java.util.Iterator;
public class Stack<Item> implements Iterable<Item>{

	public class Node {
		Item item;
		Node next;
	}
	

	private int count;
	private Node first;
	
	public Stack() { 
		count = 0;
		first = new Node();
	}
	public Iterator<Item> iterator() {
		return new ListIterator();
	}
	private class ListIterator implements Iterator<Item> {
		private Node current = first;
		public boolean hasNext() {
			return current.next != null;
		}
		public Item next() {
			Item item = current.item;
			current = current.next;
			return item;
		}	
	}
	public void push(Item item) {
		Node p = new Node();
		p.item = item;
		p.next = first;
		first = p;
		count ++;
	}
	public Item pop() {
		if (isEmpty()) return ""; 
		p = first;
		first = first.next;
		p.next = null;
		count--;
		return p.item;
	}
	public boolean isEmpty() {  
		return count == 0;
	}
	public int size() {
		return count;
	}
	// è¯»å–ä¸€è¡Œnä¸ªå­—ç¬¦ä¸²ï¼Œé‡-popï¼Œå¦åˆ™pushï¼Œæœ€åæ‰“å°size
	public static void main(String[] args) {
		String s;
		Stack<String> stack = new Stack<String>();
		while (!StdIn.isEmpty()) {
			s = StdIn.readString();
			if (s.equals("-")) stack.pop(); // string.equals(string2);
			else stack.push(s);
		}
		StdOut.println(stack.size());
		for (String k : stack) {
			StdOut.println(k);
		}
	}	
}


```
##### implement(using resizing array)
```java
	private class ListIterator implement Iterable<Item> {
		private current = 0;
		public boolean hasNext() {
			return current != stack.length-1;
		}
		public Item next() {
			Item item = stack[current];
			current ++;
			return item;
		}	
	}
```
#### bag
å½“æˆ‘ä»¬ä¸éœ€è¦è€ƒè™‘é¡ºåºçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä»…ä»…éœ€è¦èƒ½å¤Ÿæ’å…¥ï¼Œå·²ç»æœ‰å¤šå°‘ä¸ªï¼Œä»¥åŠè¾“å‡ºæ‰€æœ‰æˆ‘ä»¬å·²ç»æœ‰çš„ã€‚â€”â€”â€”â€”â€”â€”bagã€‚
##### implement
é”™è¯¯ï¼š1. å¿˜äº†import java.util.Iterator;
2. methodé‡Œé¢çš„å˜é‡ä¸éœ€è¦å†å®šä¹‰private publicäº†ï¼Œè¿™ä¸ªæ˜¯classçš„å˜é‡éœ€è¦å®šä¹‰çš„ã€‚
3. æ‰€æœ‰<>é‡Œé¢çš„item éƒ½å¿…é¡»æ˜¯ <Item> , ç±»å‹åç§°ï¼Œè€Œä¸æ˜¯item
4. `private class ListIterator implements Iterator<Item>` é‡Œåªæœ‰ä¸€ä¸ª`<Item>` ï¼Œä¸åƒ`public class Bag<Item> implements Iterable<Item>` é‡Œæœ‰ä¸¤ä¸ªã€‚
5. `class Node` é‡Œä¸éœ€è¦å†å®šä¸€ä¸ª`private`äº†ã€‚
6. æ’å…¥çš„æ—¶å€™ä¸è¦åˆ†èƒŒåŒ…æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœè®©`p.next=null`ï¼Œåè€Œä¼šå‡ºé”™ã€‚
7. Nodeæ˜¯ç”¨private class
```java
import java.util.Iterator; // 1 
public class Bag<Item> implements Iterable<Item> {
	private Node first;
	private int count;
	
	private class Node { // 7 private class
		Item item; 	// 5 ä¸éœ€è¦å†å£°æ˜privateäº†
		Node next;
	}
	public Bag() {
		first = new Node();
		count = 0;
	}
	public void add(Item item) {
		Node p = new Node();  // 2
		p.item = item;        // 6 æ’å…¥çš„æ—¶å€™ä¸ç”¨è€ƒè™‘æ˜¯å¦ä¸ºç©ºã€‚
		p.next = first;
		first = p;
		count++;
	}
	public boolean isEmpty() {
		return count == 0;
	}
	public int size() {
		return count;
	}
	public Iterator<Item> iterator() { // 3 Iterator<Item>
		return new ListIterator();
	}
	private class ListIterator implements Iterator<Item> { //4 æ­¤æ—¶ä¸å†æ˜¯private class ListIterator<Item>  implements Iterator<Item>
		private Node current = first;
		public boolean hasNext() {
			return current.next != null;
		}
		public Item next() {
			Item item = current.item;
			current = current.next;
			return item;
		}
	} 
}

```
##### bagæ€»ç»“
æœ¬æ¥è¿˜æƒ³ç€è¯´bagè¿™ä¹ˆç®€å•ï¼Œè¦ä¸ç„¶å°±ä¸ç”¨è‡ªå·±å®ç°ä¸€éè·³è¿‡å»å¾—äº†ï¼Œä½†ç§‰æ‰¿ç€â€œä¿è¯è‡ªå·±è¦ä¼šâ€çš„åŸåˆ™ï¼Œè¿˜æ˜¯å†™ä¸€è¾¹ï¼Œç»“æœ6ä¸ªé”™ï¼Œå¥½å‡ ä¸ªé”™è¿˜æ˜¯ç”¨ä»£ç æ¯”è¾ƒè½¯ä»¶æ‰èƒ½å‘ç°çš„ã€‚
å½“ç„¶è¿™é‡Œé¢ä¹Ÿæœ‰iteratorå®ç°èµ·æ¥æ¯”è¾ƒç¹ççš„åŸå› ï¼Œä½†å´æ˜¯è¿˜æ˜¯ç»™è‡ªå·±æé†’äº†â€”â€”ä¸è¦ä»¥ä¸ºè‡ªå·±ä¼šï¼Œä¸è¦ä»¥ä¸ºè‡ªå·±ç†è§£ï¼Œç»™è‡ªå·±æ—¶é—´ç¢ç£¨å°è¯•æ€»æ²¡é”™çš„ã€‚
#### stack and queue applications
##### stack - dijkstra's two-stack algorithm
é”™è¯¯ï¼š1.`public static void main(String[] args)` å°‘äº† void
2. `Stack<Double> value = new Stack<Double>();` å°‘äº†æœ€åçš„æ‹¬å·ã€‚
```java
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class Dijkstra {

	public static void main(String[] args) {
			Stack<Double> value = new Stack<Double>();
			Stack<String> operand = new Stack<String>();
			String input, out;
			double inputValue, out1, out2, result;
			while (!StdIn.isEmpty()) {
				input = StdIn.readString();
				if (input.equals("(")) continue;
				else if (input.equals("+") || input.equals("-") || input.equals("*") || input.equals("ï¼")) operand.push(input);
				else if (!input.equals(")")) {
					inputValue = Double.parseDouble(input);
					value.push(inputValue);
				}
				else if (input.equals(")")) {
					out1 = value.pop();
					out2 = value.pop();
					out = operand.pop();
					if (out.equals("+")) value.push((out1+out2));
					else if (out.equals("-")) value.push((out1-out2));
					else if (out.equals("*")) value.push((out1*out2));
					else if (out.equals("/")) value.push((out1/out2));
				}
			}
			result = value.pop();
			if (value.isEmpty() && operand.isEmpty()) StdOut.println(result);
			else StdOut.println("Wrong exprassion.");
		}
}
```
#### programming assignment
##### dequeue
é”™è¯¯ï¼š @é”™è¯¯
1. `throw new java.lang.IllegalArgumentException(); ` æŠ›å‡ºå¼‚å¸¸çš„æ—¶å€™ï¼Œå¼‚å¸¸åé¢è¦åŠ ï¼ˆï¼‰;
2. é“¾è¡¨çš„å°¾éƒ¨åˆ é™¤ç»“ç‚¹ï¼Œå°±è¦è€ƒè™‘åŒå‘é“¾è¡¨ã€‚
3. å¾ªç¯è¾“å‡ºæ—¶å‘ç°æœ€åä¸€ä¸ªç»“ç‚¹æ²¡æœ‰è¾“å‡ºï¼Œå› ä¸º`last.next=null` ä½†æŒ‰ç…§`while(i.hasNext())` å½“iæ—¶æœ€åä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œi.hasNext()æ—¶falseï¼Œå°±ä¸ä¼šè¾“å‡ºã€‚æ‰€ä»¥æ”¹æˆ`oldlast.next=null` .
```java
import java.util.Iterator;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class Dequeue<Item> implements Iterable<Item> {
	private class Node {
		Item item;
		Node next;
		Node before;  // 2
	}
	private Node first;
	private Node last;
	private int count;
	public Dequeue() {
		first = new Node();
		last = new Node();
		count = 0;
	}
	public boolean isEmpty() {
		return count == 0;
	}
	public int size() {
		return count;
	}
	public void addFirst(Item item) {
		if (item == null) throw new java.lang.IllegalArgumentException();  // 1
		Node p = new Node();
		p.item = item;
		p.next = first;
		first.before = p;
		first = p;
		if (count == 0) last = first;
		count++;
		// StdOut.println(first.item);
	}
	public void addLast(Item item) {
		if (item == null) throw new java.lang.IllegalArgumentException();
		Node p = new Node();
		p.item = item;
		p.next = null;
		last.next = p;
		p.before = last;
		last = p;
		if (count == 0) first = last;
		count++;
		// StdOut.println(last.item);
	}
	public void removeFirst() {
		if (count == 0) throw new java.util.NoSuchElementException();
		first = first.next;
		count--;
	}
	public void removeLast() {
		if (count == 0) throw new java.util.NoSuchElementException();
		Node oldlast = last;
		last = last.before;
		oldlast.next = null;  // 3
		count--;
	}
	private class ListIterator implements Iterator<Item> {
		private Node current = first;
		public boolean hasNext() {
			return current.next != null;
		}

		public Item next() {
			Item item = current.item;
			current = current.next;
			return item;
		}	
		public void remove() {
			throw new java.lang.UnsupportedOperationException();
		}
	}
	public Iterator<Item> iterator() {
		return new ListIterator();
	}
	public static void main(String[] args) {
		int s;
		Dequeue<Integer> stack = new Dequeue<Integer>();
		while (!StdIn.isEmpty()) {
			s = StdIn.readInt();
			if (s>5) stack.addFirst(s);
			if (s<5 && s != -1 && s != 0) stack.addLast(s);
			if (s == -1) stack.removeFirst();
			if (s == 0) stack.removeLast();
		}
		for (int k : stack) {
			StdOut.println(k);
		}


	}
		
}



```
##### RandomizedQueue
é”™è¯¯ï¼š
1. è¿˜æ˜¯iterationçš„æ—¶å€™æœ€åä¸€ä¸ªnodeæ²¡æ³•å‡ºæ¥ã€‚è§£å†³æ–¹æ¡ˆå°±æ˜¯åœ¨enqueueçš„æ—¶å€™åŠ ä¸€ä¸ªè™šæ‹Ÿçš„empty nodeï¼Œæ”¾åœ¨last.nextåé¢ã€‚
```java
import java.util.Iterator;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
import edu.princeton.cs.algs4.StdRandom;
public class RandomizedQueue<Item> implements Iterable<Item> {
	private class Node {
		Item item;
		Node next;
	}
	private Node first;
	private Node last;
	private int count;
	public RandomizedQueue() {
		first = new Node();
		last = new Node();
		count = 0;
	}

	public boolean isEmpty() {
		return count == 0;
	}

	public int size() {
		return count;
	}

	public void enqueue(Item item) {
		if (item == null) throw new java.lang.IllegalArgumentException();
		Node p = new Node();
		Node empty = new Node();  // 1-
		p.item = item;
		p.next = empty;
		last.next = p;
		last = p;
		if (count == 0) first = last;
		count++;
	}

	public Item dequeue() {
		if (count == 0) throw new java.util.NoSuchElementException();
		Node before = randomNode();
		Item item = before.next.item;
		before.next = before.next.next;
		return item;
	}
	private Node randomNode() {
		int randomValue = StdRandom.uniform(count);
		int stopCount = 1;
		Node start = first;
		Node temp;
		while (stopCount < randomValue-1) {
			temp = start.next;
			start = temp;
			stopCount++;
		}
		return start;
	}
	public Item sample() {
		if (count == 0) throw new java.util.NoSuchElementException();
		Node before = randomNode();
		return before.next.item;		

	}

	private class ListIterator implements Iterator<Item> {
		private Node current = first;
		public boolean hasNext() {
			return current.next != null;
		}

		public Item next() {
			Item item = current.item;
			current = current.next;
			return item;
		}	
		public void remove() {
			throw new java.lang.UnsupportedOperationException();
		}
	}
	public Iterator<Item> iterator() {
		return new ListIterator();
	}
	public static void main(String[] args) {
		int s;
		RandomizedQueue<Integer> stack = new RandomizedQueue<Integer>();
		while (!StdIn.isEmpty()) {
			s= StdIn.readInt();
			if (s != -1 && s != 0) stack.enqueue(s);
		}
		for (int k : stack) {
			StdOut.println(k);
		}
		StdOut.println(stack.dequeue());
		for (int k : stack) {
			StdOut.println(k);
		}
		// StdOut.println(stack.sample());
	}
}
```
###### client-Permutation
```java
public class Permutation {
	public static void main(String[] args) {
		int k = Integer.parseInt(args[0]);
		RandomizedQueue<String> q = new RandomizedQueue<String>();
		while (!StdIn.isEmpty()) {
			q.enqueue(StdIn.readString());
		}
		for (int i = 0; i<k; i++){
			StdOut.println(q.dequeue());
		}
	}
}
```
### week3
- æ’åºæ¨¡æ¿
```java
public class Example {
	public static void sort(Comparable[] a){
	// å¾…å¡«å……
	}
	private static boolean less(Comparable v, Comparable w) {
		return v.compareTo(w) < 0;	
	}
	private static void exch(Comparable[] a, int i, int j){
		Comparable t = a[i];
		a[i] = a[j];
		a[j] = t;
	}
	private static void show(Comparable[] a) {
		for (int i=0; i<a.length; i++){
			StdOut.print(a[i]+" ");
		}
		StdOut.println();
 	}
 	public static boolean isSorted(Comparable[] a) {
		for (int i=0; i<a.length;i++){
			if (less(a[i],a[i-1])) return false;
		}
		return true;
	}
	public static void main(String[] args) {
		String[] a = In.readStrings();
		sort(a);
		assert isSorted(a);
		show(a);
	}

}
```

#### sorting Introduction
1. sorting examples: Double, String, File, it can sort any kind of data.
2. How can 1 happen? How can sort() know how to compare data of all data type like File ?
		sort() use callback, sort() function calls back object's compareTo() method. å³æ•°æ®ç»“æ„æœ¬èº«æ˜¯æœ‰compareTo()çš„methodï¼Œæƒ³æƒ³ä¸€ä¸ªåˆ†æ•°çš„æ•°æ®ç»“æ„ï¼Œä½ è‚¯å®šéœ€è¦å†™ä¸€ä¸ªæ¯”è¾ƒä¸¤ä¸ªåˆ†æ•°çš„methodã€‚sort()ä¸éœ€è¦çŸ¥é“æ¯ä¸€ç§æ•°æ®å¦‚ä½•æ¯”å¤§å°ï¼Œå®ƒåªéœ€è¦åœ¨æ¯”è¾ƒå¤§å°çš„æ—¶å€™è°ƒç”¨è¿™ä¸ªmethodï¼Œå¾—åˆ°ç»“è®ºå³å¯ã€‚
3. java å¦‚ä½•å®ç°ï¼Ÿ javaç”¨ä¸€ä¸ªComparable interface, æ‰€æœ‰class æ·»åŠ äº†è¿™ä¸ªinterfaceï¼Œå®ç°ä¸€ä¸ªcompareTo methodï¼ˆè¿”å›å€¼ä¸º-1ï¼Œ1ï¼Œ0ï¼‰ï¼Œç„¶åsort()ä¸­å°±å¯ä»¥ç›´æ¥è°ƒç”¨ï¼Œå¾—åˆ°ä¸¤è€…æ¯”è¾ƒç»“æœã€‚
		
		```java
			// object  implementation
			public class File implements Comparable<File> {
				...
				public int compareTo(File b) {
					...
					return -1;
					...
					return 1;
					...
					return 0;
				}
			}
			// sort implementation
			public static void sort(Comparable[] a) {
				...
				if (a[i].compareTo(a[j]) < 0)
					exch(a,i,j);
			}
		```
4. è‡ªå·±å†™çš„data typeæ€ä¹ˆåšï¼Ÿ
	1. é¦–å…ˆï¼Œè¯¥æ•°æ®ç»“æ„çš„æ¯”è¾ƒé€»è¾‘è¦ä¿è¯total ruleï¼š
			1. if v <= w, w <= v, then v=w
			2. if v <= w, w <= x, then v <= x;
			3. either v <= w, w >= v;
	2. implements comparable api
	3. throws an exception if incompatible types or null type;
5. æ€ä¹ˆéªŒè¯æ˜¯å¦violate(break) total rule ? é¢˜ç›®åšé”™äº†ã€‚	@confused

```java
public class Temperature implements Comparable<Temperature> {
    private final double degrees;
    
    public Temperature(double degrees) {
        if (Double.isNaN(degrees))
            throw new IllegalArgumentException();
        this.degrees = degrees;
    }

    public int compareTo(Temperature that) {
        double EPSILON = 0.1;
        if (this.degrees < that.degrees - EPSILON) return -1;
        if (this.degrees > that.degrees + EPSILON) return +1;
        return 0;
    }
    ...
}

```
	- æŠŠa.compareTo(b) > 0, a.compareTo(b) < 0, a.compareTo(b) = 0 ä¸‰ç§æƒ…å†µçš„çœŸå®aï¼Œbå†™å‡ºæ¥ã€‚
		- `a.compareTo(b) < 0` â€”â€”> `a < b-0.1`
		- `a.compareTo(b) > 0` â€”â€”> `a > b+0.1`
		- `a.compareTo(b) = 0` â€”â€”> `b + 0.1>= a >= b-0.1`
	- é€æ¡éªŒè¯ï¼š
		1. if v <= w, w <= v, then v=wï¼›
			a.compareTo(b) <=0 -->  
#### selection sort

- æ ¸å¿ƒæ€æƒ³ï¼šä¸æ–­æ‰¾å‡ºiå³ä¾§æœ€å°çš„å…ƒç´ ï¼Œå’Œa[i]äº¤æ¢ã€‚
```java
public class Selection {
// å…¶ä½™ç›´æ¥ç”¨exampleçš„ä»£ç 
	public static void sort(comparable[] a) {
		int i = 0;
		while (i < a.length) {
			int min = i;
			for (int j = i+1; j<a.length; j++) {
				if (less(a[j], a[min]))
					min = j;			
			}
			exch(a,i,min);
			i++;
		}
	}	
}

```
- è°ƒç”¨æ¬¡æ•°ï¼šlesséœ€è¦è°ƒç”¨(n-1)+(n-2)+...+0 ~ n^2æ¬¡ï¼Œexchå¾ˆç®€å•ï¼Œnæ¬¡ã€‚
- æ—¶é—´ï¼šquadratic time. æœ€å¥½æƒ…å†µæ˜¯already sortedï¼Œno exch, but still needs n^2 to find.
#### insertion sort
- æ ¸å¿ƒæ€æƒ³ï¼šå¾€å·¦å†’æ³¡ï¼Œå¦‚æœless(i,left),exch(i,left),ç›´åˆ°åœä¸‹æ¥oråˆ°é¡¶ã€‚
```java
public class Insertion {
	public static void sort(Comparalbe[] a) {
		for (int i = 0; i<a.length; i++) {
			for (int j=i; j>0; j--) {
				if (less(a[j],a[j-1]))
					exch(a,j,j-1);
				else break;
			}
		}
	}
}
```
- è°ƒç”¨æ¬¡æ•°ï¼š
	- æœ€ä¼˜ï¼šalready sortedã€‚N-1 lessï¼Œ 0 exch
	- æœ€åï¼šdescend sortedã€‚1/2 n^2 less, 1/2 n^2 exch.
- partially-sorted arrays
